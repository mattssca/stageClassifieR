#' Predict Bladder Cancer Stage (MIBC vs NMIBC)
#'
#' This function predicts bladder cancer stage classification as either muscle-invasive 
#' bladder cancer (MIBC) or non-muscle-invasive bladder cancer (NMIBC) using a random 
#' forest classifier trained on gene expression data and molecular signatures.
#'
#' @param these_predictions A prediction object from LundTaxR containing subtype 
#'   predictions, signature scores, and optionally expression data. This should be 
#'   the output from LundTaxR classification functions.
#' @param these_sample_ids Character vector of sample IDs to include in the prediction. 
#'   If NULL (default), all samples in the prediction object will be used.
#' @param expression_data Optional matrix or data frame of gene expression data with 
#'   genes as rows and samples as columns. If NULL (default), expression data will 
#'   be extracted from the these_predictions object.
#' @param this_threshold Numeric threshold for classification probability (default = 0.596). 
#'   Samples with probability >= threshold are classified as MIBC, others as NMIBC.
#'
#' @import dplyr tibble
#' 
#' @return A data frame with three columns:
#'   \itemize{
#'     \item sample_id: Character vector of sample identifiers
#'     \item prediction: Character vector of stage predictions ("mibc" or "nmibc")
#'     \item probability: Numeric vector of prediction probabilities for MIBC class
#'   }
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Extracts molecular subtype classifications from LundTaxR predictions
#'   \item Processes signature scores for progression risk and molecular grades
#'   \item Combines expression data for top predictive genes with clinical features
#'   \item Uses a pre-trained random forest classifier to predict stage
#'   \item Returns predictions with associated probabilities
#' }
#' 
#' Missing features are imputed using mean values from the training data. The 
#' classifier requires specific molecular subtypes and signature scores that are 
#' generated by the LundTaxR classification system.
#'
#' @examples
#' \dontrun{
#' # Basic usage with LundTaxR predictions
#' stage_results <- predict_stage(lundtax_predictions)
#' 
#' # Predict for specific samples only
#' selected_samples <- c("sample1", "sample2", "sample3")
#' stage_results <- predict_stage(
#'   these_predictions = lundtax_predictions,
#'   these_sample_ids = selected_samples
#' )
#' 
#' # Use custom expression data and threshold
#' stage_results <- predict_stage(
#'   these_predictions = lundtax_predictions,
#'   expression_data = my_expression_matrix,
#'   this_threshold = 0.6
#' )
#' 
#' # View results
#' head(stage_results)
#' table(stage_results$prediction)
#' }
#'
#' @seealso 
#' \code{\link[LundTaxR]{classify_samples}} for generating the required prediction object
#'
#' @export
#' 
predict_stage = function (these_predictions = NULL,
                          these_sample_ids = NULL,
                          expression_data = NULL,
                          this_threshold = 0.596){


  #set RF object
  classifier = UroStageClass


  cat("Running NMIBC/MIBC Predictor...\n\n")

  #get score columns
  score_cols <- c("sample_id", "proliferation_score",
                   "progression_score", "progression_risk",
                   "molecular_grade_who_1999", "molecular_grade_who_2022",
                   "molecular_grade_who_1999_score", "molecular_grade_who_2022_score",
                   "immune141_up", "b_cells", "t_cells",
                   "t_cells_cd8", "nk_cells",
                   "cytotoxicity_score", "neutrophils",
                   "monocytic_lineage", "macrophages",
                   "m2_macrophage", "myeloid_dendritic_cells",
                   "stromal141_up", "endothelial_cells",
                   "fibroblasts", "smooth_muscle")

  scores_cols <- c("proliferation_score",  "progression_score", "molecular_grade_who_1999_score", "molecular_grade_who_2022_score",
                   "immune141_up", "b_cells", "t_cells", "t_cells_cd8", "nk_cells", "cytotoxicity_score", "neutrophils",
                   "monocytic_lineage", "macrophages", "m2_macrophage", "myeloid_dendritic_cells", "stromal141_up",
                   "endothelial_cells", "fibroblasts", "smooth_muscle")

  #subset subtype info
  subtype_df = as.data.frame(these_predictions$predictions_5classes) %>%
    rownames_to_column("sample_id") %>%
    rename(subtype_5_class = `these_predictions$predictions_5classes`)

  if(!is.null(these_sample_ids)){
    cat("using provided sample IDs...\n")

    subtype_df = subtype_df %>%
      filter(sample_id %in% these_sample_ids)

    print(nrow(subtype_df))
    cat("n Samples available\n\n")
  }

  #subset signature scores
  signature_scores = these_predictions$scores %>%
    rownames_to_column("sample_id") %>%
    select(all_of(score_cols))

  if(!is.null(these_sample_ids)){
    signature_scores = signature_scores %>%
      filter(sample_id %in% these_sample_ids)
  }

  #get expression data
  if(is.null(expression_data)){
    cat("Using expression data within the prediction return...\n\n")
    expression_data = these_predictions$data
  }else{
    expression_data = expression_data
  }

  if(!is.null(these_sample_ids)){
    expression_data = expression_data %>%
      select(all_of(these_sample_ids))
  }

  #enforce factors
  subtype_df$subtype_5_class <- as.factor(subtype_df$subtype_5_class)
  signature_scores$progression_risk <- as.factor(signature_scores$progression_risk)
  signature_scores$molecular_grade_who_1999 <- as.factor(signature_scores$molecular_grade_who_1999)
  signature_scores$molecular_grade_who_2022 <- as.factor(signature_scores$molecular_grade_who_2022)

  #enforce numeric columns
  signature_scores[scores_cols] <- lapply(signature_scores[scores_cols], as.numeric)

  #harmonize samples ina ll objects
  common_samples <- Reduce(intersect, list(
    subtype_df$sample_id,
    signature_scores$sample_id,
    colnames(expression_data)
  ))

  #select top genes from training and transform
  epxr_sub <- expression_data[top_genes, common_samples]
  epxr_sub_t <- t(epxr_sub)
  epxr_sub_df <- as.data.frame(epxr_sub_t)

  #add subtype
  epxr_sub_df$subtype_5_class <- subtype_df$subtype_5_class[match(common_samples, subtype_df$sample_id)]

  #add signature scores (excluding sample_id)
  sig_scores_matched <- signature_scores[match(common_samples, signature_scores$sample_id), ]
  sig_scores_matched <- sig_scores_matched[, setdiff(names(sig_scores_matched), "sample_id")]
  epxr_sub_df <- cbind(epxr_sub_df, sig_scores_matched)

  #debug
  missing_cols <- setdiff(colnames(classifier$trainingData), colnames(epxr_sub_df))

  #remove "nmibc_vs_mibc" from missing_cols
  missing_cols <- setdiff(missing_cols, c(".outcome","nmibc_vs_mibc"))

  #print missing columns
  cat("Missing features:")
  print(missing_cols)
  cat("These features will be imputed using the mean from the training data...\n\n")

  expr_df_clean <- epxr_sub_df[, colSums(!is.na(epxr_sub_df)) > 0]
  expr_df_model <- expr_df_clean[, intersect(colnames(classifier$trainingData), colnames(expr_df_clean))]

  #use mean from training data, or 0 if not available
  for (feat in missing_cols) {
    mean_val <- mean(classifier$trainingData[[feat]], na.rm = TRUE)
    expr_df_model[[feat]] <- mean_val
  }

  #run predictor
  probs <- predict(classifier, expr_df_model, type = "prob")[, "mibc"]
  preds <- ifelse(probs >= this_threshold, "mibc", "nmibc")

  # compile return as a data frame
  results <- data.frame(
    sample_id = common_samples,
    prediction = preds,
    probability = probs,
    stringsAsFactors = FALSE
  )

  cat("Success!")

  #return results
  return(results)
}
